# AdminPlus 开发规范

## 目录

1. [后端开发规范](#1-后端开发规范)
   - [1.1 技术选型](#11-技术选型)
   - [1.2 JPA 实体开发规范](#12-jpa-实体开发规范)
   - [1.3 DTO/VO 规范](#13-dtovo-规范)
   - [1.4 树形结构规范](#14-树形结构规范)
   - [1.5 树形构建工具](#15-树形构建工具)
   - [1.6 代码规范](#16-代码规范)
   - [1.7 包结构](#17-包结构)
   - [1.8 命名规范](#18-命名规范)
   - [1.9 注解规范](#19-注解规范)
   - [1.10 数据库规范](#110-数据库规范)
   - [1.11 API 规范](#111-api-规范)
2. [前端开发规范](#2-前端开发规范)
3. [Git 提交规范](#3-git-提交规范)
4. [代码审查要点](#4-代码审查要点)
5. [注意事项](#5-注意事项)
6. [性能优化规范](#6-性能优化规范)
7. [安全规范](#7-安全规范)
8. [测试规范](#8-测试规范)
9. [部署规范](#9-部署规范)

---

## 1. 后端开发规范

### 1.1 技术选型

- **Spring Boot**: 3.5.0
- **JDK**: 21（强制使用新特性）
- **Spring Security**: 6.3+（Native JWT）
- **Spring Data JPA**: 最新版
- **PostgreSQL**: 16+
- **Lombok**: 仅用于 Entity
- **ID 生成策略**: 雪花算法 (String 类型)

### 1.2 JPA 实体开发规范

#### 1.2.1 核心依赖与配置

**确保 pom.xml 中包含 Lombok 和 JPA，并在启动类开启审计**：

```java
@Configuration
@EnableJpaAuditing(auditorAwareRef = "auditorAware")
public class JpaConfig {
    @Bean
    public AuditorAware<String> auditorAware() {
        return () -> Optional.ofNullable(SecurityUtils.getCurrentUserId());
    }
}
```

#### 1.2.2 基础实体类（BaseEntity）

**规范：所有 Entity 必须继承此类**

```java
@Data
@EqualsAndHashCode(callSuper = false)
@MappedSuperclass
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    private String id;  // 雪花算法生成

    @CreatedDate
    @Column(name = "create_time", nullable = false, updatable = false)
    private Instant createTime;

    @LastModifiedDate
    @Column(name = "update_time", nullable = false)
    private Instant updateTime;

    @CreatedBy
    @Column(name = "create_user", nullable = false, updatable = false)
    private String createUser;

    @LastModifiedBy
    @Column(name = "update_user", nullable = false)
    private String updateUser;

    @Column(name = "deleted", nullable = false)
    private Boolean deleted = false;

    @PrePersist
    public void prePersist() {
        if (this.id == null || this.id.isEmpty()) {
            this.id = IdUtils.nextIdStr();
        }
        if (this.deleted == null) {
            this.deleted = false;
        }
    }
}
```

#### 1.2.3 树形实体基类规范（TreeEntity）

**为树形结构实体（部门、菜单等）设计专用基类**：

```java
@Getter
@Setter
@MappedSuperclass
public abstract class TreeEntity<E extends TreeEntity<E>> extends BaseEntity {

    /**
     * 节点名称/标题
     */
    @Column(name = "name", nullable = false)
    protected String name;

    /**
     * 父节点
     * 规范1: fetch = LAZY (必须懒加载，防止级联全表查询)
     * 规范2: insertable/updatable = true (由 JPA 维护外键)
     */
    @ManyToOne(fetch = FetchType.LAZY)
    @JoinColumn(name = "parent_id")
    protected E parent;

    /**
     * 子节点列表
     * 规范1: mappedBy 指向子类的 parent 属性
     * 规范2: CascadeType.ALL (父节点删，子节点全删)
     * 规范3: orphanRemoval = true (从 List 移除即删库)
     */
    @OneToMany(mappedBy = "parent", cascade = CascadeType.ALL, orphanRemoval = true)
    @OrderBy("sort ASC, createTime DESC")
    protected List<E> children = new ArrayList<>();

    /**
     * 排序权重
     */
    @Column(name = "sort")
    protected Integer sort = 0;

    /**
     * 祖级列表 (Materialized Path 优化查询)
     * 格式: "0,1,5," 用于快速查找所有子孙：WHERE ancestors LIKE '0,1,5,%'
     */
    @Column(name = "ancestors", length = 500)
    protected String ancestors;

    /**
     * 辅助方法：添加子节点
     */
    public void addChild(E child) {
        this.children.add(child);
        child.setParent((E) this);
    }
}
```

#### 1.2.4 Entity 开发强制规范

| 规范项 | 要求 | 说明 |
|--------|------|------|
| **继承基类** | ✅ 强制 | 所有 Entity 必须继承 BaseEntity（中间表除外） |
| **Lombok 避坑** | ✅ 强制 | 使用 `@ToString(exclude = {"parent", "children"})` 防止 StackOverflow |
| **懒加载** | ✅ 强制 | 所有 `@ManyToOne` 必须配置 `fetch = FetchType.LAZY` |
| **相等性判断** | ✅ 推荐 | `equals` 只比较 ID，`hashCode` 返回固定值 |
| **逻辑删除** | ✅ 强制 | 使用 `@Where(clause = "deleted = false")` |
| **DTO 隔离** | ✅ 强制 | 禁止直接返回 Entity 给前端 |
| **索引命名** | ✅ 强制 | 索引名称必须包含表名前缀，格式：`idx_{表名}_{字段名}` |
| **唯一约束命名** | ✅ 强制 | 唯一约束使用 `uk_{表名}_{字段名}` 格式 |
| **唯一约束位置** | ✅ 强制 | 在 `@Table` 中定义，禁止使用 `@Column(unique = true)` |

> **⚠️ 中间表（关联表）例外规范**
>
> 多对多关联的中间表（如 `sys_user_role`、`sys_role_menu`）不需要审计字段，因此**不继承 BaseEntity**。
>
> **中间表实体规范：**
> - 不继承 `BaseEntity`
> - 只包含 `id` 和关联字段（如 `user_id`、`role_id`）
> - 不需要 `@Where` 逻辑删除注解
> - 仍需定义索引和唯一约束
>
> **中间表示例：**
> ```java
> @Data
> @Entity
> @Table(name = "sys_user_role",
>        uniqueConstraints = {
>            @UniqueConstraint(name = "uk_user_role_user_role", columnNames = {"user_id", "role_id"})
>        },
>        indexes = {
>            @Index(name = "idx_user_role_user_id", columnList = "user_id"),
>            @Index(name = "idx_user_role_role_id", columnList = "role_id")
>        })
> public class UserRoleEntity {
>
>     @Id
>     @GeneratedValue(strategy = GenerationType.IDENTITY)
>     private String id;
>
>     @Column(name = "user_id", nullable = false)
>     private String userId;
>
>     @Column(name = "role_id", nullable = false)
>     private String roleId;
> }
> ```

**Entity 实现示例**（正确规范）：

```java
@Data
@EqualsAndHashCode(callSuper = true, exclude = {"parent", "children"})
@ToString(callSuper = true, exclude = {"parent", "children"})
@NoArgsConstructor
@Entity
@Table(name = "sys_dept")
@SQLDelete(sql = "UPDATE sys_dept SET deleted = true WHERE id = ?")
@Where(clause = "deleted = false")
public class DeptEntity extends BaseEntity {

    @Column(name = "parent_id")
    private String parentId;

    @Column(name = "name", nullable = false, length = 50)
    private String name;

    @Column(name = "code", length = 50)
    private String code;

    @Column(name = "sort_order")
    private Integer sortOrder;

    @Column(name = "status", nullable = false)
    private Integer status = 1;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DeptEntity that = (DeptEntity) o;
        return getId() != null && getId().equals(that.getId());
    }

    @Override
    public int hashCode() {
        return getClass().hashCode();
    }
}
```

**Lombok 避坑清单**：

```java
// ❌ 错误：会导致 StackOverflowError
@Data
public class DeptEntity extends BaseEntity {
    private DeptEntity parent;
    private List<DeptEntity> children;
}

// ✅ 正确：排除双向关联字段
@Data
@EqualsAndHashCode(callSuper = true, exclude = {"parent", "children"})
@ToString(callSuper = true, exclude = {"parent", "children"})
public class DeptEntity extends BaseEntity {
    private DeptEntity parent;
    private List<DeptEntity> children;
}
```

### 1.3 DTO/VO 规范

#### 1.3.1 规范要求

| 场景 | 使用类型 | 说明 |
|------|----------|------|
| Controller 入参 | `record` | 带 `@NotBlank` 等校验注解 |
| Controller 出参 | `record` | 去除敏感字段，处理层级关系 |
| Entity 转换 | 禁止直接返回 Entity | 必须转为 VO |

**DTO 入参示例**：

```java
public record UserLoginReq(
    @NotBlank String username,
    @NotBlank String password
) {}
```

**VO 出参示例**：

```java
public record UserVO(
    String id,
    String username,
    String nickname,
    Instant createTime
) {}
```

**树形结构 VO 示例**：

```java
public record DeptTreeVO(
    String id,
    String label,      // 前端组件通常叫 label 或 name
    String parentId,
    Integer sort,
    List<DeptTreeVO> children,  // 子节点集合
    Boolean hasChildren          // 是否包含子节点（可选，用于前端懒加载图标
) {
    public DeptTreeVO(String id, String label, String parentId, Integer sort) {
        this(id, label, parentId, sort, new ArrayList<>(), null);
    }
}
```

### 1.4 树形结构规范

#### 1.4.1 树形实体设计规范

1. **父子关系映射**
   - `@ManyToOne` 父节点必须 `FetchType.LAZY`
   - `@OneToMany` 子节点必须 `mappedBy = "parent"`

2. **层级路径优化**（Materialized Path）
   - 使用 `ancestors` 字段存储祖级路径，如 "0,1,5,"
   - 查询所有子孙: `WHERE ancestors LIKE '0,1,5,%'`

3. **循环引用检测**
   - 更新父节点时，防止将节点设置为自己的子孙节点

#### 1.4.2 树形查询规范

**查询层级数据（推荐一次性查询 + 内存组装）**：

```java
public List<DeptTreeVO> getTree() {
    // 1. 一次性查询所有数据
    List<DeptEntity> entities = deptRepository.findAll(Sort.by("sortOrder"));

    // 2. Entity -> VO (扁平转换)
    List<DeptTreeVO> voList = entities.stream().map(dept -> {
        String pid = (dept.getParentId() != null) ? dept.getParentId() : "0";
        return new DeptTreeVO(dept.getId(), dept.getName(), pid, dept.getSortOrder());
    }).collect(Collectors.toList());

    // 3. 构建树
    return TreeUtils.buildTree(voList);
}
```

**查询子孙节点**（使用 ancestors 字段）：

```java
public List<DeptEntity> getDescendants(String deptId) {
    DeptEntity dept = deptRepository.findById(deptId)
        .orElseThrow(() -> new BizException("部门不存在"));
    String ancestors = dept.getAncestors() + dept.getId() + ",";
    return deptRepository.findByAncestorsStartingWith(ancestors);
}
```

### 1.5 树形构建工具

**O(n) 复杂度的树形构建器**：

```java
public class TreeUtils {

    /**
     * 内存中构建树形结构
     * @param list 扁平的 VO 列表
     * @return 树形结构列表
     */
    public static List<DeptTreeVO> buildTree(List<DeptTreeVO> list) {
        List<DeptTreeVO> tree = new ArrayList<>();

        // 1. 将 List 转为 Map (Key: ID, Value: VO)
        Map<String, DeptTreeVO> map = list.stream()
                .collect(Collectors.toMap(DeptTreeVO::getId, v -> v));

        // 2. 遍历组装
        for (DeptTreeVO node : list) {
            String pid = node.getParentId();

            // 判断是否为根节点 (pid 为 null 或 "0")
            if (pid == null || pid.equals("0")) {
                tree.add(node);
            } else {
                // 找爸爸
                DeptTreeVO parent = map.get(pid);
                if (parent != null) {
                    parent.getChildren().add(node);
                }
            }
        }
        return tree;
    }
}
```

### 1.6 代码规范

#### Switch 表达式

```java
var roleName = switch (roleType) {
    case "ADMIN" -> "管理员";
    case "USER" -> "普通用户";
    default -> throw new IllegalArgumentException("未知角色");
};
```

#### 虚拟线程使用

**开启虚拟线程（application.yml）**：

```yaml
spring:
  threads:
    virtual:
      enabled: true
```

**异步服务方法示例**：

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class AsyncService {

    @Async
    public CompletableFuture<List<UserVO>> getUserListAsync() {
        return CompletableFuture.supplyAsync(() -> {
            log.info("使用虚拟线程处理用户列表查询");
            // IO 密集型任务
            return userList;
        });
    }
}
```

#### 权限控制注解

**启用方法级权限控制（SecurityConfig）**：

```java
@EnableMethodSecurity
public class SecurityConfig {
    // ...
}
```

**Controller 中使用权限注解**：

```java
@PreAuthorize("hasAuthority('user:add')")
@PostMapping
public ApiResponse<UserVO> createUser(@Valid @RequestBody UserCreateReq req) {
    // ...
}

@PreAuthorize("hasRole('ADMIN')")
@DeleteMapping("/{id}")
public ApiResponse<Void> deleteUser(@PathVariable String id) {
    // ...
}
```

#### 分页查询实现

**Repository 分页查询**：

```java
@Repository
public interface UserRepository extends JpaRepository<UserEntity, String> {

    @Query("SELECT u FROM UserEntity u WHERE u.deleted = false")
    Page<UserEntity> findAllByDeletedFalse(Pageable pageable);
}
```

**Service 分页查询**：

```java
public PageResult<UserVO> getUserList(Integer page, Integer size, String keyword) {
    Pageable pageable = PageRequest.of(page - 1, size, Sort.by("createTime").descending());

    Specification<UserEntity> spec = (root, query, cb) -> {
        List<Predicate> predicates = new ArrayList<>();
        predicates.add(cb.equal(root.get("deleted"), false));

        if (StringUtils.hasText(keyword)) {
            predicates.add(cb.or(
                cb.like(root.get("username"), "%" + keyword + "%"),
                cb.like(root.get("nickname"), "%" + keyword + "%")
            ));
        }

        return cb.and(predicates.toArray(new Predicate[0]));
    };

    Page<UserEntity> pageResult = userRepository.findAll(spec, pageable);

    return new PageResult<>(
        pageResult.getContent().stream().map(this::toVO).toList(),
        pageResult.getTotalElements(),
        pageResult.getNumber() + 1,
        pageResult.getSize()
    );
}
```

### 1.7 包结构

```
com.adminplus
├── common/          # 公共模块
│   ├── constants/   # 常量定义
│   ├── exception/   # 异常处理
│   └── properties/  # 配置属性
├── config/          # 配置类
├── controller/      # 控制器
├── pojo/            # 数据对象
│   ├── dto/         # 数据传输对象（record）
│   │   ├── req/     # 请求 DTO
│   │   └── resp/    # 响应 VO
│   └── entity/      # 实体类
├── repository/      # JPA Repository
├── service/         # 服务层
│   └── impl/        # 服务实现
└── utils/           # 工具类
```

### 1.8 命名规范

#### 类名
- PascalCase（User/UserService/UserController）

#### 方法名
- 小驼峰式（getUserById/createUser/updateUser/deleteUser）

#### 变量名
- 小驼峰式（userName/currentPage/loading）

### 1.9 注解规范

#### Controller

```java
@Slf4j
@RestController
@RequestMapping("/sys/users")
@RequiredArgsConstructor
@Tag(name = "用户管理", description = "用户增删改查")
public class UserController {
    // ...
}
```

#### Service

```java
@Slf4j
@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
    @Transactional
    public UserVO createUser(UserCreateReq req) {
        // ...
    }
}
```

#### Repository

```java
@Repository
public interface UserRepository extends JpaRepository<UserEntity, String> {
    Optional<UserEntity> findByUsername(String username);
}
```

#### Entity

```java
@Data
@Entity
@Table(name = "sys_user")
public class UserEntity extends BaseEntity {
    @Id
    private String id;

    @Column(name = "username", nullable = false, length = 50)
    private String username;
}
```

### 1.10 数据库规范

#### 表名
- `sys_` 前缀，小写蛇形（sys_user, sys_role）

#### 字段名
- 小写蛇形（user_name, create_time）

#### 主键
- `id`（VARCHAR，雪花算法）

#### 时间字段
- `create_time`, `update_time`（TIMESTAMP WITH TIME ZONE）

#### 逻辑删除
- `deleted`（BOOLEAN，false 未删除 / true 已删除）

#### 状态字段
- `status`（INTEGER，1 正常 / 0 禁用）

#### 索引命名规范

**强制规则：索引名称必须包含表名前缀，确保全局唯一**

**普通索引命名格式**：`idx_{表名}_{字段名}`

**唯一索引命名格式**：`uk_{表名}_{字段名}` (Unique Key)

| 索引类型 | 命名格式 | 示例 |
|---------|---------|------|
| 普通索引 | `idx_{表名}_{字段名}` | `idx_user_username` |
| 唯一索引 | `uk_{表名}_{字段名}` | `uk_user_username` |
| 复合索引 | `idx_{表名}_{字段1}_{字段2}` | `idx_user_dept_status` |
| 复合唯一索引 | `uk_{表名}_{字段1}_{字段2}` | `uk_role_user_perm` |

**正确示例**：

```java
@Table(name = "sys_user",
       uniqueConstraints = {
           @UniqueConstraint(name = "uk_user_username", columnNames = "username"),
           @UniqueConstraint(name = "uk_user_email", columnNames = "email")
       },
       indexes = {
           @Index(name = "idx_user_username", columnList = "username"),
           @Index(name = "idx_user_email", columnList = "email"),
           @Index(name = "idx_user_phone", columnList = "phone"),
           @Index(name = "idx_user_status", columnList = "status"),
           @Index(name = "idx_user_deleted", columnList = "deleted"),
           @Index(name = "idx_user_dept_id", columnList = "dept_id")
       })

@Table(name = "sys_dict",
       indexes = {
           @Index(name = "idx_dict_type", columnList = "dict_type"),
           @Index(name = "idx_dict_status", columnList = "status"),
           @Index(name = "idx_dict_deleted", columnList = "deleted")
       })

@Table(name = "sys_menu",
       indexes = {
           @Index(name = "idx_menu_parent_id", columnList = "parent_id"),
           @Index(name = "idx_menu_ancestors", columnList = "ancestors"),
           @Index(name = "idx_menu_sort_order", columnList = "sort_order"),
           @Index(name = "idx_menu_visible", columnList = "visible"),
           @Index(name = "idx_menu_status", columnList = "status"),
           @Index(name = "idx_menu_type", columnList = "type"),
           @Index(name = "idx_menu_deleted", columnList = "deleted")
       })
```

**错误示例**：

```java
// ❌ 错误1：多个表使用相同的索引名称，会导致冲突
@Table(name = "sys_user", indexes = {@Index(name = "idx_status", ...)})
@Table(name = "sys_menu", indexes = {@Index(name = "idx_status", ...)})

// ❌ 错误2：唯一约束未使用 uk 前缀
@Table(name = "sys_user",
       uniqueConstraints = {
           @UniqueConstraint(name = "idx_username", columnNames = "username")  // 应该是 uk_username
       })

// ❌ 错误3：字段级 unique 未指定名称（会自动生成，难以管理）
@Column(name = "username", unique = true)  // 不推荐，应在 @Table 中定义
```

**表名前缀对照表**：

| 表名 | 普通索引前缀 | 唯一索引前缀 | 示例 |
|------|------------|------------|------|
| sys_user | idx_user_ | uk_user_ | idx_user_username / uk_user_username |
| sys_menu | idx_menu_ | uk_menu_ | idx_menu_parent_id / uk_menu_code |
| sys_dept | idx_dept_ | uk_dept_ | idx_dept_parent_id / uk_dept_code |
| sys_dict | idx_dict_ | uk_dict_ | idx_dict_type / uk_dict_type |
| sys_dict_item | idx_dict_item_ | uk_dict_item_ | idx_dict_item_dict_id |
| sys_role | idx_role_ | uk_role_ | idx_role_code / uk_role_code |

**唯一约束使用场景**：

| 场景 | 是否唯一 | 示例 |
|------|---------|------|
| 用户名/邮箱/手机 | ✅ 唯一 | `uk_user_username`, `uk_user_email` |
| 角色编码 | ✅ 唯一 | `uk_role_code` |
| 字典类型 | ✅ 唯一 | `uk_dict_type` |
| 菜单路径 | ⚠️ 业务决定 | 同一父节点下可能唯一 |
| 部门编码 | ✅ 唯一 | `uk_dept_code` |
| 外键字段 | ❌ 不唯一 | 使用普通索引 `idx_user_dept_id` |

**注意事项**：
1. **索引名称在数据库中必须全局唯一**，不能跨表重复
2. **唯一约束使用 `uk_` 前缀**，普通索引使用 `idx_` 前缀
3. 使用 `ddl-auto: update` 时，重复索引名会导致启动警告
4. 生产环境建议使用 `ddl-auto: validate` 配合 Flyway/Liquibase 迁移
5. 字段级 `unique = true` 会自动生成索引名，**不推荐使用**，应在 `@Table` 中明确定义
6. 复合唯一约束用于多字段组合唯一性（如：用户+权限+角色）

### 1.11 API 规范

#### URL
- RESTful（GET/POST/PUT/DELETE）
- 资源复数形式（/sys/users, /sys/roles）

#### 请求头

```
Content-Type: application/json
Authorization: Bearer {token}
```

#### 响应格式

**使用 ApiResponse 统一封装**：

```java
// 成功响应
return ApiResponse.ok(data);
return ApiResponse.ok("操作成功", data);

// 失败响应
return ApiResponse.fail("操作失败");
return ApiResponse.fail(400, "参数错误");
```

**响应格式**：

```json
{
  "code": 200,
  "message": "操作成功",
  "data": {...},
  "timestamp": 1704010000000
}
```

#### 分页格式

```json
{
  "code": 200,
  "message": "查询成功",
  "data": {
    "records": [...],
    "total": 100,
    "page": 1,
    "size": 10
  },
  "timestamp": 1704010000000
}
```

---

## 2. 前端开发规范

### 2.1 技术选型

- **Vue**: 3.5+（Composition API）
- **Vite**: 6+
- **Pinia**: 3.x（Setup Store）
- **Element Plus**: 最新版
- **Axios**: HTTP 客户端
- **JavaScript**: ES2022+（不使用 TypeScript）

### 2.2 目录结构

```
src/
├── api/             # API 接口层
├── assets/          # 静态资源
├── components/      # 全局组件
├── directives/      # 自定义指令
├── layout/          # 布局组件
├── router/          # 路由配置
├── stores/          # Pinia 状态管理
├── utils/           # 工具函数
└── views/           # 页面组件
    ├── auth/        # 认证相关页面
    └── system/      # 系统管理页面
```

### 2.3 代码规范

#### 组件定义

```vue
<script setup>
import { ref } from 'vue'
import { getUserList } from '@/api/user'

const loading = ref(false)
const tableData = ref([])

const getData = async () => {
  loading.value = true
  try {
    const data = await getUserList()
    tableData.value = data
  } finally {
    loading.value = false
  }
}
</script>
```

#### 变量声明

```javascript
const loading = ref(false)
const tableData = ref([])
```

#### 响应式

```javascript
const form = ref({
  username: '',
  password: ''
})
```

### 2.4 命名规范

#### 组件文件
- PascalCase（UserList.vue, UserForm.vue）

#### 页面文件
- kebab-case（user/index.vue, role/index.vue）

#### API 文件
- kebab-case（user.js, role.js）

#### Store 文件
- kebab-case（user.js, role.js）

#### 变量命名
- 小驼峰式（userName, currentPage, loading）

#### 常量命名
- 大写+下划线（API_BASE_URL, PAGE_SIZE）

#### 函数命名
- 小驼峰式（getUserList, validateForm）

#### 事件处理
- handle 前缀（handleAdd, handleEdit, handleDelete）

#### Store 函数
- use 前缀（useUserStore, usePermissionStore）

### 2.5 Store 规范

```javascript
// stores/user.js
import { defineStore } from 'pinia'
import { ref } from 'vue'

export const useUserStore = defineStore('user', () => {
  const token = ref(localStorage.getItem('token') || '')
  const user = ref(null)

  const setToken = (val) => {
    token.value = val
    localStorage.setItem('token', val)
  }

  const login = async (username, password) => {
    // ...
  }

  return {
    token,
    user,
    setToken,
    login
  }
})
```

### 2.6 API 封装

```javascript
// api/user.js
import request from '@/utils/request'

export const getUserList = (params) => {
  return request({
    url: '/sys/users',
    method: 'get',
    params
  })
}

export const createUser = (data) => {
  return request({
    url: '/sys/users',
    method: 'post',
    data
  })
}
```

### 2.7 路由规范

```javascript
{
  path: '/system/user',
  name: 'SystemUser',
  component: () => import('@/views/system/User.vue'),
  meta: { title: '用户管理', requiresAuth: true }
}
```

---

## 3. Git 提交规范

### 3.1 提交格式

```
<type>(<scope>): <subject>
```

### 3.2 Type 类型

- `feat`: 新功能
- `fix`: 修复 bug
- `docs`: 文档更新
- `style`: 代码格式（不影响代码运行的变动）
- `refactor`: 重构
- `test`: 测试相关
- `chore`: 构建过程或辅助工具的变动

### 3.3 Scope 范围

- `user`: 用户模块
- `role`: 角色模块
- `menu`: 菜单模块
- `auth`: 认证模块
- `common`: 公共模块

### 3.4 示例

```bash
feat(user): 添加用户批量删除功能
fix(role): 修复角色分配权限时的 bug
docs(readme): 更新 README 文档
style(user): 统一代码格式
refactor(auth): 重构 JWT 认证逻辑
test(user): 添加用户单元测试
chore(deps): 升级 Spring Boot 版本
```

---

## 4. 代码审查要点

### 4.1 后端审查要点

- [ ] DTO 是否使用 record 类型
- [ ] Entity 是否继承 BaseEntity
- [ ] Entity 是否使用 `@ToString(exclude = {"parent", "children"})`
- [ ] 索引名称是否包含表名前缀（格式：`idx_{表名}_{字段名}`）
- [ ] 唯一约束是否使用 `uk_{表名}_{字段名}` 格式
- [ ] 唯一约束是否在 `@Table` 中定义（不使用 `@Column(unique = true)`）
- [ ] 是否使用 Switch 表达式
- [ ] Service 方法是否添加 @Transactional
- [ ] 是否统一异常处理
- [ ] 是否统一返回格式
- [ ] 是否遵循包结构规范
- [ ] 是否遵循命名规范
- [ ] 是否添加必要的注释
- [ ] 树形结构查询是否使用内存构建
- [ ] 是否避免直接返回 Entity

### 4.2 前端审查要点

- [ ] 组件是否使用 `<script setup>`
- [ ] 变量是否使用 const 声明
- [ ] Store 是否使用 Setup Store
- [ ] 是否遵循目录结构规范
- [ ] 是否遵循命名规范
- [ ] 是否添加必要的注释
- [ ] 是否处理 loading 状态
- [ ] 是否处理错误情况

---

## 5. 注意事项

1. **前端不使用 TypeScript**
2. **数据库表统一使用 sys_ 前缀**
3. **API 统一返回格式**
4. **分页数据使用 records、total、page、size**
5. **时间字段统一使用 create_time 和 update_time**
6. **逻辑删除统一使用 deleted 字段**
7. **状态字段统一使用 status（1 正常 / 0 禁用）**
8. **DTO 和 VO 必须使用 record 类型**
9. **所有 Entity 必须继承 BaseEntity**
10. **树形实体使用 `@ToString(exclude = {...})` 防止循环引用**
11. **禁止直接返回 Entity 给前端**

---

## 6. 性能优化规范

### 6.1 后端性能优化

#### 数据库查询优化

**避免 N+1 查询问题**：

```java
// ❌ 错误：N+1 查询
public List<UserVO> getUserList() {
    List<UserEntity> users = userRepository.findAll();
    return users.stream().map(user -> {
        List<RoleEntity> roles = userRoleRepository.findByUserId(user.getId());
        return toVO(user, roles);
    }).toList();
}

// ✅ 正确：使用 JOIN 查询
@Query("SELECT u FROM UserEntity u LEFT JOIN FETCH u.roles WHERE u.deleted = false")
List<UserEntity> findAllWithRoles();
```

**使用缓存**：

```java
@Service
@RequiredArgsConstructor
public class DictService {

    @Cacheable(value = "dict", key = "#dictType")
    public List<DictItemVO> getDictItems(String dictType) {
        return dictItemRepository.findByDictType(dictType);
    }

    @CacheEvict(value = "dict", key = "#dictType")
    public void updateDict(String dictType) {
        // 更新后清除缓存
    }
}
```

#### 树形查询优化

**一次性查询 + 内存构建**：

```java
// ✅ 推荐：O(n) 复杂度
public List<DeptTreeVO> getTree() {
    List<DeptEntity> entities = deptRepository.findAll();
    List<DeptTreeVO> voList = entities.stream().map(this::toVO).toList();
    return TreeUtils.buildTree(voList);
}

// ❌ 避免：递归查库，O(n²) 复杂度
public List<DeptTreeVO> getTree() {
    return buildTreeRecursive(null);
}
```

### 6.2 前端性能优化

#### 组件懒加载

```javascript
{
  path: '/system/user',
  component: () => import('@/views/system/User.vue')
}
```

#### 防抖和节流

```javascript
import { debounce } from 'lodash-es'

const handleSearch = debounce(async (keyword) => {
  await getUserList({ keyword })
}, 300)
```

---

## 7. 安全规范

### 7.1 后端安全

#### SQL 注入防护

```java
// ✅ 安全：使用 JPA 方法
List<UserEntity> findByUsername(String username);

// ✅ 安全：使用 @Query 参数化查询
@Query("SELECT u FROM UserEntity u WHERE u.username = :username")
UserEntity findByUsername(@Param("username") String username);

// ❌ 危险：拼接 SQL
String sql = "SELECT * FROM sys_user WHERE username = '" + username + "'";
```

#### XSS 防护

```java
@Service
@RequiredArgsConstructor
public class UserService {

    public UserVO createUser(UserCreateReq req) {
        // 过滤 HTML 标签
        String cleanNickname = HtmlUtils.htmlEscape(req.nickname());
        // ...
    }
}
```

#### 密码加密

```java
@Service
@RequiredArgsConstructor
public class UserService {

    private final PasswordEncoder passwordEncoder;

    public UserVO createUser(UserCreateReq req) {
        user.setPassword(passwordEncoder.encode(req.password()));
        // ...
    }
}
```

### 7.2 前端安全

#### XSS 防护

```vue
<!-- ✅ 安全 -->
<div v-text="userInput"></div>

<!-- ❌ 危险 -->
<div v-html="userInput"></div>
```

---

## 8. 测试规范

### 8.1 后端测试

#### 单元测试

```java
@SpringBootTest
class UserServiceTest {

    @Autowired
    private UserService userService;

    @MockBean
    private UserRepository userRepository;

    @Test
    void testCreateUser() {
        // Given
        UserCreateReq req = new UserCreateReq("test", "123456", "测试用户", null, null, null);

        // When
        UserVO user = userService.createUser(req);

        // Then
        assertNotNull(user);
        assertEquals("test", user.username());
    }
}
```

---

## 9. 部署规范

### 9.1 Docker 部署

#### 后端 Dockerfile

```dockerfile
FROM eclipse-temurin:21-jre-alpine

WORKDIR /app

COPY target/adminplus-backend.jar app.jar

EXPOSE 8080

ENTRYPOINT ["java", "-jar", "app.jar"]
```

#### docker-compose.yml

```yaml
version: '3.8'

services:
  postgres:
    image: postgres:16-alpine
    environment:
      POSTGRES_DB: adminplus
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: postgres
    ports:
      - "5432:5432"
    volumes:
      - postgres-data:/var/lib/postgresql/data

  backend:
    build: ./backend
    ports:
      - "8080:8080"
    depends_on:
      - postgres
    environment:
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/adminplus

volumes:
  postgres-data:
```

---

## 附录：JPA Model 开发规范清单

### 基础规范

- [ ] 所有 Entity 继承 BaseEntity
- [ ] 树形实体继承 TreeEntity
- [ ] Lombok 使用 `@ToString(exclude = {"parent", "children"})`
- [ ] 懒加载配置：`@ManyToOne(fetch = FetchType.LAZY)`
- [ ] 相等性判断：`equals` 只比较 ID，`hashCode` 返回固定值
- [ ] DTO 隔离：Controller 入参用 DTO，出参用 VO
- [ ] 严禁直接返回 Entity 给前端
- [ ] 索引名称包含表名前缀：`idx_{表名}_{字段名}`
- [ ] 唯一约束使用 `uk_{表名}_{字段名}` 格式
- [ ] 唯一约束在 `@Table` 中定义，不使用 `@Column(unique = true)`

### 树形结构规范

- [ ] 查询时优先使用 `findAll + 内存组装`
- [ ] 删除/更新复杂子树时，利用 `ancestors` 字段辅助定位
- [ ] 更新父节点时，检测循环引用

### 性能规范

- [ ] 避免 N+1 查询，使用 JOIN FETCH
- [ ] 静态数据使用缓存
- [ ] 树形结构查询使用 O(n) 复杂度算法
